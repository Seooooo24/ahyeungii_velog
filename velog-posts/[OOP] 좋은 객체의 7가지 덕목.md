<p><a href="https://codingnuri.com/seven-virtues-of-good-object/">레퍼런스</a>
해당 글은 위의 글을 읽은 후 이해한 내용을 토대로 하여 정리의 목적으로 작성한 글임을 알립니다.</p>
<p>마틴 파울러 왈</p>
<blockquote>
<p>라이브러리는 본질적으로 호출 가능한 함수의 집합으로서, 오늘날에는 보통 클래스에 모여 있다.</p>
</blockquote>
<p>&quot;클래스에 모여 있는 함수&quot; 객체지향 프로그래밍의 클래스에 대해서 흔히 하는 오해입니다. 클래스는 함수를 모아두는 곳이 아니고, 객체는 자료구조가 아닙니다.</p>
<p>그렇다면 &quot;적절한&quot; 객체는 대체 무엇일까요? 이는 사람마다 의견이 분분히 갈리는 주제이지만, 매우 중요한 주제임이 틀림 없습니다. 우리는 객체가 무엇인지 알아야 비로소 객체지향 소프트웨어를 작성할 수 있기 때문입니다.(자바와 같은 객체지향 언어가 도와줘서 몰라도 짤 순 있지만...)</p>
<p>다음은 좋은 객체의 품질을 나열한 것입니다.</p>
<h2 id="클래스-vs-객체">클래스 vs. 객체</h2>
<p><img alt="" src="https://velog.velcdn.com/images/ahyeungii/post/8b37c179-a84a-486a-ae89-6b952de21b6e/image.png" /></p>
<p>객체에 관해 이야기하기에 앞서, <strong>클래스</strong>란 무엇인가에 대해서 정의해봅시다!
<em>클래스는 붕어빵 틀이고 인스턴스는 붕어빵이다.</em> 한 번 쯤 본 적 있을 이 예시에서 알 수 있듯이, 클래스는 객체가 태어나는(<em>인스턴스화</em> 라고 이 행위를 부르기도 한다) 곳이다. 클래스의 주된 책임은 필요에 따라 새로운 객체를 <strong>생성</strong>하고 더는 사용하지 않을 때 객체를 <strong>파괴</strong>하는 것입니다. 또, 클래스는 해당 클래스의 자식들이 어떤 모습이어야 하고, 어떻게 행동해야 하는지를 알고 있습니다. 다시 말해서, 클래스 자신의 자식들이 따라야만 하는 _계약_에 대해서 알고 있습니다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/ahyeungii/post/d30a4524-4080-4d7a-a997-c72a52e79131/image.png" />
이따금 클래스를 &quot;객체 템플릿&quot;이라고 부르기도 합니다.(이거 붕어빵 틀 예시인가... ㅎ) 그러나 이 정의는 정확하다고 하기 어렵습니다. 이 정의는 누군가가 템플릿을 가지고 그것을 사용하여 객체를 만들어낸다고 가정하는 것이고, 클래스는 수동적인 위치라고 생각하게 됩니다. (그럼 자동 붕어빵 기계라고 생각하자...)
그럴 수도 있지만, 엄밀히 말하자면 이 정의는 개념적으로 틀렸습니다. 클래스가 객체를 만들어내는 과정 중 다른 누구도 이곳에 관여해서는 안 됩니다. 이 과정에는 클래스와 그것의 자식들만 있을 뿐입니다. 
객체는 클래스에게 또 다른 객체를 만들라고 요청하고, 클래스는 객체를 만들어냅니다. 이것이 전부입니다. RUBY는 이 개념을 직관적으로 잘 표현합니다.</p>
<pre><code>photo = File.new('/tmp/photo.png')</code></pre><p>photo 객체는 File 클래스에 의해서 생성되고(new는 클래스에 대한 진입점), 한 번 생성된 객체는 스스로 동작합니다. 자신을 누가 만들었는지, 형제가 얼마나 더 있는지 알아서는 안 됩니다. 
그렇기 때문에, 리플렉션 프로그래밍(반성 프로그래밍...? 뭔지 공부해봐야 할 듯)은 바보 같은 생각입니다.(제 생각 아니고 글쓴이 생각입니다)
이제 객체 자체를 비롯하여 객체의 가장 좋은 측면과 가장 나쁜 측면에 대해서 알아봅시다.</p>
<h3 id="1-객체는-현실-세계에-존재한다">1. 객체는 현실 세계에 존재한다</h3>
<p><img alt="" src="https://velog.velcdn.com/images/ahyeungii/post/a9c158f6-fa12-4819-89d4-944854f068fa/image.png" />
나도 객체랍니다~</p>
<p>먼저, 객체는 생명체입니다. 심지어 객체를 의인화하여 인간과 같이 취급해야 합니다.(인간이든... 반려동물이든... 소통 가능한 것) 
이것은 기본적으로 객체가 자료구조 또는 단순한 함수의 집합이 아니라는 것을 의미합니다. <strong>객체는 자신의 생명주기, 행위, 습관을 지닌 독립적인 개체입니다.</strong></p>
<p>직원, 부서, HTTP 요청, MySQL 안의 테이블, 파일 속 한 줄, 파일 자체는 적절한 객체입니다. 그것들은 현실 세계에 존재하며, 우리가 소프트웨어를 종료하더라도 존재합니다! 좀 더 정확히 말하자면, 객체는 현실 세계의 피조물(앞서 말한 현실 세계의 객체)을 <strong>대표</strong>하는 것입니다. 객체는 다른 모든 객체 앞에 있는 그러한 현실 세계의 <strong>피조물의 대리자(proxy)</strong>입니다. 피조물이 존재하지 않는다면, 객체 또한 존재할 수 없습니다.</p>
<pre><code>photo = File.new('/tmp/photo.png')
puts photo.width()</code></pre><p>이 예제에서는 File로 하여금 새로운 photo 객체를 생성하도록 요청하고 있는데, 이 객체는 디스크 상의 실제 파일을 대표할 것입니다. (실제 파일 경로 넣어줬음!) 여러분은 파일이 무언가 가상적이고, 컴퓨터를 켰을 때만 존제하는 것이라고 생각하고 있었을 수도 있습니다. 글쓴이도 이 말에 동의하나, &quot;현실 세계&quot;의 의미를 수정하고자 합니다; <strong>객체가 살아가는 프로그램의 범위에서 벗어난 곳에 존재하는 모든 것.</strong> 
디스크 파일은 위 프로그램 밖에 존재하지 않습니까?  프로그램 내에서 그것의 대표자를 만들어내는 것이 완벽하게 맞는 것은 바로 그런 이유에서 나왔습니다.</p>
<h4 id="놀랍게도">놀랍게도!</h4>
<p>컨트롤러, 파서, 필터, 검증기, 서비스 로케이터, 싱글턴, 팩터리는 좋은 객체가 <strong>아닙니다.</strong>(대부분의 GoF 패턴은 <a href="https://www.yegor256.com/2016/02/03/design-patterns-and-anti-patterns.html">안티패턴</a>이라고 합니다. 역시나 파사드도 안티 패턴이네요......) 이것들은 소프트웨어 밖의 현실 세계에는 존재하지 않습니다. 단지 다른 객체와 함께 사용하기 위해 만들어낸 것입니다. 그것들은 인공적인 가짜 피조물입니다. XML 파서 같은 것이 실제 객체를 대표하나요? 아무도 대표하지 않는 것을 알 수 있습니다.</p>
<p>이들은 이름을 바꾸면 좋아질 수 있는 경우가 있습니다.(일부는 답이 없습니다...)
예를 들어, XMLParser는 ParsebleXML로 이름을 바꾸고, 프로그램 바깥의 실제 XML 문서를 대표할 수 있습니다.</p>
<p>늘 다음과 같이 자문해 보세요! &quot;내가 만든 객체의 배후에 존재하는 현실 객체는 무엇일까?&quot;
이 질문의 답을 찾을 수 없다면, 리팩토링 해봅시다.</p>
<h3 id="2-객체가-계약에-따라-동작한다">2. 객체가 계약에 따라 동작한다.</h3>
<p><img alt="" src="https://velog.velcdn.com/images/ahyeungii/post/f4237d64-97ff-4ec7-a841-440f9338018e/image.png" /></p>
<p>좋은 객체란 언제나 계약에 따라 동작합니다. 객체는 자신의 특성이 아니라 자신이 준수하는 계약 때문에 사용되길 예상합니다.
한편으로, 우리가 객체를 사용할 때는 특정 클래스의 일부 특정 객체가 우리를 위해 동작하도록 차별하거나 예상해서는 안 됩니다. 객체가 우리가 원하는 일을 하기만 한다면 해당 객체가 만들어진 클래스, 성별, 종교에 관심을 두어서는 안 됩니다.
이해가 잘 안 가나요?</p>
<p>예를 들어, 화면에 사진을 보여주고 싶을 때, 사진을 PNG 형식의 파일로부터 읽어오고 싶습니다. 이를 위해 DataFile 클래스의 객체와 계약해서 해당 이미지의 바이너리 콘텐츠를 가져다 주도록 요청하려고 합니다.</p>
<p>그런데 잠깐, 해당 콘텐츠를 정확히 어디에서 가져와야 할지(디스크 상의 파일, HTTP 요청, 또는 드롭박스 내의 문서)에 대해 내가 관심이 있어야 할까요? 사실 그렇지 않습니다. 내가 관심 있는 것은 어떤 객체가 나에게 PNG 콘텐츠가 담긴 바이트 배열을 준다는 것입니다. 따라서, 내 계약은 다음과 같은 모습일 것입니다.</p>
<pre><code>interface Binary {
  byte[] read();
}</code></pre><p>이제, DataFile 뿐만이 아니라 어떤 클래스의 어떤 객체라도 나를 위해 일해줄 수 있습니다. 그 객체가 자격을 갖추기 위해 해야 하는 일이라고는 Binary 인터페이스를 구현함으로써 계약을 준수하는 것 뿐입니다.</p>
<p>여기서 발견할 수 있는 규칙은 간단합니다. 좋은 객체 안에 담긴 모든 공용 메서드는 인터페이스 상에 선언된, 상응하는 메서드를 구현해야 한다는 것입니다!(리스코프 치환 원칙과도 이어지네요) 여러분이 만든 객체에 어떤 인터페이스에서도 상속되지 않은 공용 메서드가 있다면, <strong>그 객체는 잘못 설계된 것입니다!</strong></p>
<p>여기에는 두 가지의 실질적인 이유가 있습니다.</p>
<ol>
<li>계약 없이 동작하는 객체는 단위 테스트에서 목킹(mocking)하는 것이 불가능합니다.(모의 데이터를 넣기 어렵다는 뜻이라고 이해하면 될 것 같습니다.)</li>
<li>계약 없는 객체는 <a href="https://en.wikipedia.org/wiki/Decorator_pattern">데코레이션</a>을 통해 확장하는 것이 불가능합니다.(다른 인스턴스의 동작에 영향을 주지 않고, 개별 객체에 동적으로 동작을 추가할 수 있게 해주는 디자인 패턴입니다. 나중에 더 읽어보기...)</li>
</ol>
<h3 id="3-객체가-고유하다">3. 객체가 고유하다.</h3>
<p>좋은 객체는 언제나 고유하기 위해서 무언가를 캡슐화 해야 합니다. 캡슐화 할 것이 없다면, 객체가 동일한 <strong>복제본</strong>을 가질 수도 있으며, 이것은 바람직하지 않다고 생각합니다. 다음은 복제본을 가질 수 있는 _나쁜 객체_의 예시입니다.</p>
<pre><code>class HTTPStatus implements Status {
  private URL page = new URL(&quot;https://localhost&quot;);
  @Override
  public int read() throws IOException {
    return HttpURLConnection.class.cast(
      this.page.openConnection()
    ).getResponseCode();
  }
}</code></pre><p>다음과 같이 HTTP 클래스의 인스턴스를 몇 개 생성할 수 있으며, 모든 인스턴스는 서로 동일한 것으로 판단될 것입니다.</p>
<pre><code>first = new HTTPStatus();
second = new HTTPStatus();
assert first.equals(second);</code></pre><p>당연히 정적(static) 메서드만이 담긴 유틸리티 클래스는 좋은 객체를 인스턴스화 할 수 없습니다. 좀 더 일반적으로 말하자면 유틸리티 클래스는 이번 글에서 언급한 이점을 아무것도 갖지 않으며 &quot;클래스&quot;라고 부를 수조차 없습니다. 유틸리티 클래스는 단순히 객체 패러다임을 <strong>엉터리</strong>로 <strong>남용</strong>하는 것에 불과하며, 현대 객체지향 언어를 발명한 사람들이 정적 메서드를 사용할 수 있게 만들어 뒀다는 이유로 <strong>존재하는 것 뿐입니다.</strong></p>
<h3 id="4-객체가-불변적이다">4. 객체가 불변적이다.</h3>
<p><img alt="" src="https://velog.velcdn.com/images/ahyeungii/post/9abb943d-3849-4876-a772-2eb616a68188/image.png" />
플레이어가 시키는대로 자신을 별별 포켓몬으로 다 바꿔버리는 뮤츠... 얘는 좋은 객체가 아니라고 할 수 있습니다. </p>
<p>좋은 객체라면 자신이 캡슐화한 상태를 <strong>절대</strong> 변경하지 않을 것입니다. 기억해 둡시다.
<strong>객체는 현실 세계에 존재하는 개체의 대표자이며, 이 객체는 객체의 전 생애에 걸쳐 변하지 않은 채로 머물러야 합니다.</strong> 다시 말해서, 객체는 그것이 대표하는 것들을 절대로 배신해서는 안 되고, 주인을 바꿔서는 안 됩니다.</p>
<p><strong>불변성(immutability)</strong>이 모든 메서드가 언제나 동일한 값을 반환한다는 것을 의미하지는 않는다는 점에 유의해야 합니다. 오히려 좋은 불변 객체는 매우 역동적입니다. 그럼에도, 자신의 내부 상태는 절대 변경하지 않습니다! 다음 예제를 봅시다.</p>
<pre><code>@Immutable
final class HTTPStatus implements Status {
  private URL page;
  public HTTPStatus(URL url) {
    this.page = url;
  }
  @Override
  public int read() throws IOException {
    return HttpURLConnection.class.cast(
      this.page.openConnection()
    ).getResponseCode();
  }
}</code></pre><p>보시면 read() 메서드가 서로 다른 값을 반환할 수 있음에도, 객체는 불변적이라는 것을 알 수 있습니다. 이 객체는 특정 웹 페이지를 가리키고, 다른 어떤 곳도 가리키지 않을 것입니다. 자신의 캡슐화된 상태를 변경하지도 않을 테고, 자신이 나타내고 있는 URL을 배신하는 일 따위는 없을 것입니다.</p>
<p>왜 불변성이 덕목일까요? <a href="https://www.yegor256.com/2014/06/09/objects-should-be-immutable.html">Object Should Be Immutable</a>에서 이를 상세하게 설명하고 있습니다. 요약하자면, 불변 객체는 다음과 같은 이유로 더 낫습니다.</p>
<ul>
<li>불변 객체는 생성, 테스트, 사용이 더 간단하다.</li>
<li>진정한 불변 객체는 언제나 <a href="https://www.yegor256.com/2017/01/17/synchronized-decorators.html">Thread-Safe</a>하다.</li>
<li>불변 객체는 <a href="https://www.yegor256.com/2015/12/08/temporal-coupling-between-method-calls.html">시간적 결합</a>을 피하는 데 도움이 된다.</li>
<li>불변 객체의 사용은 부수 효과를 발생시키지 않는다.(방어적 복사를 하지 않아도 된다)</li>
<li>불변 객체는 언제나 실패 원자성을 띤다.</li>
<li>불변 객체는 캐싱하기가 훨씬 더 쉽다.</li>
<li>불변 객체는 <a href="https://www.yegor256.com/2014/05/13/why-null-is-bad.html">NPE</a>를 방지한다.</li>
</ul>
<p>물론, 좋은 객체는 객체의 상태를 변경해서 URL을 배신하도록 강제할 수 있는 설정자 메서드를 갖지 않습니다. 다시 말해서 setURL() 메서드를 도입할 경우, HTTPStatus 클래스에 심각한 실수를 저지르는 것입니다!
(setter 사용을 지양해야 하는 이유!!! 이때까지 설명~)</p>
<p>게다가, 불변 객체는 <a href="https://www.yegor256.com/2014/11/07/how-immutability-helps.html">How Immutability Helps</a> 라는 글에서 설명하는 것과 같이 언제나 여러분으로 하려금 좀 더 응집력 있고, 견고하며, 이해하기 쉬운 설계를 하도록 강제한다.</p>
<h3 id="5-객체의-클래스에-정적-멤버가-없다">5. 객체의 클래스에 정적 멤버가 없다.</h3>
<p><img alt="" src="https://velog.velcdn.com/images/ahyeungii/post/123ba26c-c07d-4c52-a155-c422b955fb02/image.png" /></p>
<p><strong>정적 멤버</strong>는 클래스의 행위를 구현하지, 객체의 행위를 구현하지 않습니다. File이라는 클래스가 있고, 이 클래스의 자식으로 size() 메서드가 있다고 해봅시다.</p>
<pre><code>final class File implements Measurable {
  @Override
  public int size() {
    // 파일의 크기를 계산해서 반환
  }
}</code></pre><p>지금까지는 괜찮습니다. size() 메서드가 이곳에 있는 이유는 Measurable 계약 때문이며, File 클래스의 모든 객체는 자신의 크기를 측정할 수 있을 것입니다. 끔찍한 실수는 이 클래스가 정적 메서드를 갖도록 설계하는 것일 것입니다.(이 같은 설계는 앞서 언급한 <a href="https://www.yegor256.com/2014/05/05/oop-alternative-to-utility-classes.html">유틸리티 클래스</a>로도 알려져 있으며, 자바, 루비를 비롯한 대부분의 객체지향 프로그래밍 언어에서 흔히들 사용됩니다.)</p>
<pre><code>// 끔찍한 설계, 사용하지 마시오!
class File {
  public static int size(String file) {
    // 파일의 크기를 계산해서 반환
  }
}</code></pre><p>이 설계는 객체지향 패러다임에 완전히 반합니다. 왜일까요? 
정적 메서드는 객체지향 프로그래밍을 <strong>클래스 지향(Class-oriented)</strong> 프로그래밍으로 바꾸기 때문입니다. (와...... 클래스 지향이랑 객체지향이랑 다른 거구나.)
size() 메서드는 객체가 아니라, _클래스의 행위_를 노출합니다. 이것이 무엇이 잘못된 걸까요? 우리가 작성한 코드에 일급 시민으로 객체와 클래스 모두 두지 못할 이유가 있나요? 객체와 클래스가 모두 메서드와 프로퍼티를 갖지 못할 이유가 있나요? (그러니까 말입니다!!!)</p>
<p><strong>문제는 클래스 지향 프로그래밍의 경우 분해(decomposition)가 더이상 작동하지 않는 데 있습니다.</strong> 복잡한 문제를 여러 부분으로 분해할 수 없는데, 전체 프로그램에 클래스의 <strong>단 하나의 인스턴스</strong>만이 존재하기 때문입니다. <a href="https://www.yegor256.com/2016/08/15/what-is-wrong-object-oriented-programming.html">OOP</a>의 위력은 객체를 범위 분해를 위한 도구로서 사용할 수 있다는 것입니다. 메서드 내에서 객체를 인스턴스화 할 경우, 해당 객체는 부여받은 특정 과업을 수행하기 위해 전념합니다. 객체는 메서드 주변의 다른 모든 객체로부터 완벽하게 고립됩니다. 이 객체는 메서드 유효범위에서 _지역 변수_에 해당합니다. 정적 메서드를 가진 클래스는 내가 해당 클래스를 어디에서 사용하건 언제나 전역 변수에 해당합니다. 이러한 이유로 이 <a href="https://www.yegor256.com/2017/05/16/monikers.html">변수</a>와의 상호작용을 다른 것들과 고립시킬 수 없습니다.</p>
<p>객체지향 원칙에 개념적으로 반하는 것 외에도 공용 정적 메서드는 몇 가지 실제적인 단점을 지니고 있습니다.</p>
<ol>
<li><strong>목킹이 불가능합니다.</strong>(PowerMock을 사용할 수도 있으나, 이렇게 할 경우 자바 프로젝트에서 저지를 수 있는 가장 끔찍한 결정이 될 것입니다... 몇 년 전 글쓴이도 그렇게 한 적이 있다고 합니다.)</li>
<li>정의상 <strong>Thread-Safe 하지 못합니다.</strong> 왜냐하면, 모든 스레드에서 접근 가능한 정적 변수와 언제나 상호작용하기 때문입니다. Thread-Safe 하게도 만들 수 있겠으나, 그러려면 언제나 명시적인 동기화가 필요할 것입니다.</li>
</ol>
<p>공용 정적 메서드를 보게 될 때마다 그 즉시 그것을 재작성하세요. 정적(또는 전역) 변수가 얼마나 끔찍한지는 굳이 언급하고 싶지도 않다고 합니다... 그건 굳이 말 하지 않아도 알 것이라고 생각한답니다...</p>
<h3 id="6-객체의-이름이-직명을-나타내지-않는다">6. 객체의 이름이 직명을 나타내지 않는다.</h3>
<p><img alt="" src="https://velog.velcdn.com/images/ahyeungii/post/cd980e26-c460-41f5-9145-2f088019cd33/image.png" />
객체의 이름은 이 객체가 무엇인지 말해야 하고, 무슨 일을 하는지 말해서는 안 됩니다. 이것은 마치 현실 세계의 객체에 이름을 부여하는 것과 마찬가지인데, '페이지 모음기' 대신 '책'을, '물 보관기' 대신 '컵'을, '몸 감싸개' 대신 '티셔츠'라고 이름을 붙이는 것과 같습니다. 물론 프린터나 컴퓨터와 같은 예외도 있으나, 그것들은 아주 최근에 발명되었고 이 글을 읽지 않는 사람들에 의해 만들어진 것들입니다. ㅎ</p>
<p>예를 들어, 다음과 같은 이름은 그것의 소유자가 누구인지에 대해서 우리에게 말해줍니다. 
사과, 파일, 일련의 HTTP 요청, 소켓, XML 문서, 사용자 리스트, 정규 표현식, 정수, PostgreSQL 테이블, 마리오(슈퍼 마리오 시리즈의 주인공). 
적절한 이름을 가진 객체는 언제나 작은 그림으로 그려질 수 있고, 심지어 정규 표현식도 그려질 수 있습니다.</p>
<p>반대로, 다음은 그것의 소유자가 무엇을 하는지 우리에게 알려주는 이름의 예시입니다.
파일 리더, 텍스트 파서, URL 검증기, XML 프린터, 서비스 로케이터, 싱글턴, 스크립트 실행기, 자바 프로그래머.
이것들 중에서 그림으로 그릴 수 있는 것이 있나요? 그렇지 않을 것입니다. 이러한 이름은 좋은 객체의 이름으로 적합하지 않습니다. 그것들은 끔찍한 설계로 이어지는 끔찍한 이름들입니다.</p>
<p>일반적으로, &quot;-er&quot;로 끝나는 이름을 피하세요. 그것들 중 대부분은 좋지 않습니다.</p>
<p>&quot;그럼 FileReader 대신 무엇을 써야 할까요?&quot; 라고 묻고 싶을 것입니다. 더 나은 이름은 무엇일까요? 어디 한 번 보자... 이미 디스크 상의 실제 파일을 나타내는 File 클래스를 가지고 있습니다. 이 이름만으로는 충분히 강력하지 않은데, 파일의 내용을 어떻게 읽어야 할지 알지 못하기 때문입니다. 그러한 능력을 지닌 좀 더 강력한 것을 만들고 싶습니다.
그것을 뭐라고 불러야 할까요? 기억해 둡시다. *<em>이름은 그것이 무엇인지를 말해야 하고, 무슨 일을 하는지 말해서는 안 됩니다. *</em>
그 객체는 무엇일까요? 그것은 데이터를 가진 파일입니다. File 같은 단순한 파일이 아니라, 데이터를 가진 좀 더 세련된 것입니다. 그럼, FileWithData나 단순히 DataFile은 어떨까요?</p>
<p>같은 논리를 다른 모든 이름에도 적용할 수 있을 것입니다. 언제나 그것이 무슨 일을 하는지가 아니라, <strong>그것이 무엇인지</strong>에 관해 생각합시다. 객체에 직명 대신 실제의, 유의미한 이름을 부여하세요.</p>
<h3 id="7-객체의-클래스가-final이나-abstract이다">7. 객체의 클래스가 Final이나 Abstract이다.</h3>
<p>좋은 객체는 final 클래스나 abstract 클래스에서 옵니다.
final 클래스는 상속을 통해 확장할 수 없는 클래스이고, abstract 클래스는 인스턴스를 가질 수 없는 클래스입니다.
간단히 말해서, 클래스는 다음과 같이 말해야 합니다. &quot;넌 나를 분해할 수 없어. 난 블랙박스야.&quot; 또는 &quot;난 이미 망가졌어. 날 먼저 고친 후에 사용해.&quot;</p>
<p>그 사이에는 아무것도 없습니다. final 클래스는 어떤 식으로도 변경할 수 없는 블랙박스입니다. final 클래스는 원래 동작 그대로 동작하고, 그것을 사용하거나 사용하지 않으면 그만입니다. final 클래스의 프로퍼티를 상속하는 또 다른 클래스는 만들 수 없습니다. final 수정자 때문에 이렇게 하는 것은 금지됩니다. 
이러한 final 클래스를 확장하는 유일한 방법은 final 클래스의 자식을 <strong>데코레이션</strong> 하는 것입니다.
HTTPStatus(앞에서 예시로 든)라는 클래스가 있고, 이 클래스가 마음에 들지 않는다고 해봅시다. 음, 이 클래스가 마음에 들긴 하지만 원하는 만큼 강력하진 않습니다. 저는 HTTP 상태가 400 이상인 경우 이 클래스가 예외를 던지게 만들고 싶습니다. 그래서, read()메서드에서 지금 하는 일 보다 더 많은 일을 했으면 좋겠습니다. 전통적인 방법은 클래스를 확장해서 이 메서드를 오버라이드 하는 것입니다.</p>
<pre><code>class OnlyValidStatus extends HTTPStatus {
  public OnlyValidStatus(URL url) {
    super(url);
  }
  @Override
  public int read() throws IOException {
    int code = super.read();
    if (code &gt;= 400) {
      throw new RuntimeException(&quot;Unsuccessful HTTP code&quot;);
    }
    return code;
  }
}</code></pre><p>이건 왜 잘못됐을까요?
이 방법이 아주 잘못된 이유는, 부모 클래스의 메서드 중 하나를 오버라이드함으로써 전체 부모 클래스의 로직을 망가뜨릴 위험을 무릅써야 하기 때문입니다. 자식 클래스에서 read() 메서드를 오버라이드 하게 되면 부모 클래스의 모~든 메서드가 자식 클래스의 새로운 버전을 사용하게 된다는 점을 기억합시다. 말 그대로 클래스에 새로운 &quot;구현의 일부&quot;를 곧바로 집어넣고 있는 것입니다. 철학적으로 말하자면, 이건 범죄 행위라고 합니다...</p>
<p>반면, final 클래스를 확장하려면 그것을 블랙박스로 간주하고 여러분만의 구현체로 그것을 장식해야 합니다(Decorator 패턴으로)</p>
<pre><code>final class OnlyValidStatus implements Status {
  private final Status origin;
  public OnlyValidStatus(Status status) {
    this.origin = status;
  }
  @Override
  public int read() throws IOException {
    int code = this.origin.read();
    if (code &gt;= 400) {
      throw new RuntimeException(&quot;Unsuccessful HTTP code&quot;);
    }
    return code;
  }
}</code></pre><p>이 클래스는 원본 클래스인 Status와 동일한 인터페이스를 구현하고 있음을 눈여겨봅시다. 
HTTPStatus의 인스턴스는 <strong>생성자를 통해 이 클래스로 전달되고 캡슐화</strong>될 것입니다. 그런 다음, 모든 호출을 가로채어 필요한 경우 다른 방식으로 구현될 것입니다. 이 설계에서는 원본 객체를 블랙박스로 취급하고, 그것의 내부 로직은 전혀 건들고 있지 않습니다. 이게 데코레이터 페턴!</p>
<p>final 키워드를 사용하지 않는다면, 누군가(여러분 자신 포함)가 클래스를 확장한 다음... 범죄 행위를 저지를 것입니다!!!!! 그러니 final을 사용하지 않는 클래스는 나쁜 설계입니다.</p>
<p>추상 클래스는 정확히 정반대의 경우입니다. 추상 클래스는 그것이 불완전하며, 지금 모습 그대로 사용 불가능함을 알립니다. 따라서 추상 클래스에 별도의 구현 로직을 집어넣어야 하며, 이때 우리가 건드릴 수 있게 허용한 곳에만 넣을 수 있습니다. 이러한 지점에는 명시적으로 abstract 메서드로 표시되어 있습니다. 예를 들어, HTTPStatus는 다음과 같을 것입니다.</p>
<pre><code>abstract class ValidatedHTTPStatus implements Status {
  @Override
  public final int read() throws IOException {
    int code = this.origin.read();
    if (!this.isValid()) {
      throw new RuntimeException(&quot;Unsuccessful HTTP code&quot;);
    }
    return code;
  }
  protected abstract boolean isValid();
}</code></pre><p>보시다시피, 이 클래스는 HTTP 코드의 유효성을 정확히 어떻게 검증해야 할지 알지 못하며, 그 부분은 상속과 isValid() 메서드의 오버라이드를 통해 로직을 주입하길 기대합니다. 이 클래스를 상속하는 것으로는 이 클래스에 대해 범죄 행위를 저지르지 않는 셈인데, 다른 메서드는 모두 final로 방어했기 때문이다.
따라서, 이 클래스는 우리의 범죄 행위에 대비하고 있고, 완벽하게 방어하고 있다.</p>
<p>정리하자면 클래스를 설계할 때는 final이나 abstract를 지정해야 하며, 그 중간은 없다.</p>
<p>구현 상속이 나쁘다는 주장에 동의한다면, 여러분이 작성하는 모든 클래스는 final 클래스여야만 한다.</p>