<p>객체지향 설계에서는 지켜야 할 5가지 원칙이 있다. 이 5가지 원칙 각각의 앞글자를 따서 SOLID 원칙이라고 부르기도 한다.</p>
<ul>
<li>SRP(Single Responsibility Principle): 단일 책임 원칙</li>
<li>OCP(Open Closed Principle): 개방 폐쇄 원칙</li>
<li>LSP(Listov Substitution Principle): 리스코프 치환 원칙</li>
<li>ISP(Interface Segregation Principle): 인터페이스 분리 원칙</li>
<li>DIP(Dependency Inversion Principle): 의존성 역전 원칙</li>
</ul>
<p>현재 객체지향 프로그래밍에서 사용하는 여러 디자인 패턴들이 이 원칙들에 입각하여 만들어졌다. </p>
<p>좋은 소프트웨어는 유연한 소프트웨어를 말한다. 유연한 소프트웨어는 변화에 대응하기 쉽다. 좋은 설계는 시스템에 새로운 요구사항이나 변경사항이 있을 때, 영향을 받는 범위가 적은 구조를 말한다. 그래서 시스템에 예상하지 못한 변경사항이 발생하더라도 잘 대처하고 확장성이 있는 시스템 구조를 만들 수 있다.</p>
<blockquote>
<p>각 원칙에는 순서가 없다. 눈에 잘 띄기 위하여 SOLID 원칙이라는 말을 사용하는 것이다.
프로젝트에 5가지 원칙을 모두 적용해야할 필요는 없다. 각 원칙은 특정 문제를 해결하기 위한 지침이라고 할 수 있다.</p>
</blockquote>
<h3 id="srp-단일-책임-원칙">SRP: 단일 책임 원칙</h3>
<p>객체는 오직 하나의 책임을 가져야 한다.(객체는 오직 하나의 변경에 대한 이유만을 가져야 한다)
객체 하나가 여러 기능을 가지게 되면 기능 하나에 대한 수정사항 때문에 객체 전체를 변경해야 하는 일이 생긴다. 단일 책임 원칙은 이런 일을 방지하여 프로그램의 유지보수성을 향상시킨다.
그러나, 한 책임의 범위는 정해져 있는 것이 아니라 프로그래머의 생각에 따라 달라질 수 있다. 따라서, 이에 대한 완벽한 해답은 존재하지 않는다.</p>
<h3 id="ocp-개방-폐쇄-원칙">OCP: 개방 폐쇄 원칙</h3>
<p>객체는 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적이어야 한다. 
기능 추가에 대한 클라이언트의 requirements가 있다면 클래스의 확장을 통하여 손쉽게 구현하면서 확장에 따른 클래스의 수정은 최소화하도록 프로그램을 작성해야 한다.</p>
<ul>
<li>확장에 개방적이다: 새로운 requirements가 발생하였을 때 코드를 추가함으로써 쉽게 기능 확장 가능</li>
<li>수정에 폐쇄적이다: 새로운 변경 사항이 발생했을 때 객체를 직접적으로 수정하지 않는다.
쉽게 말해서 OCP는 객체지향의 추상화 특성을 사용하여 관계를 구축하는 것을 권장한다. 다형성과 확장을 권장한다.</li>
</ul>
<h3 id="lsp-리스코프-치환-원칙">LSP: 리스코프 치환 원칙</h3>
<p>자식 타입이 언제나 부모 타입으로 교체될 수 있어야 한다.
이는 객체지향의 다형성을 이용하기 위한 원칙이다. 다형성의 특징을 이용하기 위하여 부모 타입으로 객체를 선언하여 자식 클래스의 인스턴스를 받으면, <strong>업캐스팅</strong>된 상태에서 부모의 메서드를 사용해도 동작이 의도대로 흘러가야 한다.
따라서 LSP 원칙을 지키기 위해서는 부모 클래스 메서드의 오버라이딩을 조심스럽게 해야 한다. 부모 클래스와 동일한 수준의 선행 조건을 기대하고 사용하는 프로그램 코드에서 예상치 못한 문제를 일으킬 수 있기 때문이다.</p>
<blockquote>
<p>업캐스팅: 자식 클래스의 객체가 부모 클래스 타입으로 형변환되는 것</p>
</blockquote>
<h3 id="isp-인터페이스-분리-원칙">ISP: 인터페이스 분리 원칙</h3>
<p>인터페이스를 각각 사용에 맞게 잘 분리해야 한다.
이는 인터페이스의 단일 책임을 강조하는 원칙이다. 이 목표는 인터페이스 분리를 통하여 이루어질 수 있다. 목표 분리는 인터페이스를 이용하는 클라이언트를 기준으로 분리한다. 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는 것이 목표이다.
그러나, 한 번 분리하여 구성한 인터페이스를 나중에 또 분리하지 않는 것이 원칙이다. (인터페이스는 한 번 구성하였으면 웬만해서 수정하면 안 되는 정책의 개념이다.)</p>
<blockquote>
<p>인터페이스는 다중 상속이 가능하므로, 분리할 수 있다면 분리하여 각 클래스에 맞게 implements하라</p>
</blockquote>
<h3 id="dip-의존-역전-원칙">DIP: 의존 역전 원칙</h3>
<p>어떤 클래스를 참조해서 사용해야 하는 상황이 생기면, 그 클래스를 직접 참조하는 것이 아니라 그 대상의 부모 요소를 참조한다.
구현한 클래스가 아닌 인터페이스에 의존해야 한다. 의존 관계를 맺을 때, 변화의 가능성이 높은 대상 보다는 불변에 가까운 대상에 의존한다. 최대한 추상적인 대상에 의존하도록 노력한다. 이렇게 되면 이 인터페이스를 implements한 클래스는 클라이언트의 어떤 변경도 없이 나중에 교체 가능하다.</p>
<blockquote>
<p>목표: 각 클래스 간 coupling 낮추기</p>
</blockquote>
<p>이는 IoC와 용어가 비슷하기에 혼동이 가능하나, 다른 개념이다. DIP는 클래스 사이의 coupling에 대한 개념이지만 IoC는 제어의 흐름에 대한 개념이다.</p>
<p>참고: <a href="https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99-SOLID">Inpa Dev</a></p>